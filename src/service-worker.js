const cacheName = 'pprmnt-1.0.0'; // need to manually update this to bust cache

const thingsToCache = [
  '/',
  './index.html',
  './favicon.df682a99.ico',
  './manifest.webmanifest',
  './peppermint.wasm', // generated by emscripten, outside of parcel
  './peppermint.js', // generated by emscripten, outside of parcel
  './src.e31bb0bc.js', // generated by parcel, the "hash" stays the same between builds,
  './peppermint.worker.f4a6b94e.js', // generated by parcel, the "hash" stays the same between builds,
  './InputMono-Regular.6e8cbed8.woff2', // generated by parcel, the "hash" stays the same between builds,
];

// perf critical bits -- if have cached version, serve cached version
const alwaysCache = [
  './peppermint.wasm',
  './peppermint.js',
  './peppermint.worker.f4a6b94e.js',
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches
      .open(cacheName)
      .then((cache) => cache.addAll(thingsToCache))
      .then(() => self.skipWaiting()),
  );
});

self.addEventListener('activate', (event) => {
  self.clients.claim();
  // do cleanup of stale cache
  event.waitUntil(
    (async () => {
      const promises = (await caches.keys()).map((maybeStale) =>
        maybeStale !== cacheName ? caches.delete(maybeStale) : null,
      );
      await Promise.all(promises);
    })(),
  );
});

self.addEventListener('fetch', (e) => {
  e.respondWith(
    (async () => {
      const { pathname } = new URL(e.request.url);
      const isAlwaysCache = alwaysCache.includes(`.${pathname}`);
      const returnCachedAsset = () =>
        caches
          .open(cacheName)
          .then((cache) => cache.match(e.request), { ignoreSearch: true })
          .then((res) => res);

      // if is always cache, hit the cache
      if (isAlwaysCache) {
        return returnCachedAsset();
      }

      //otherwise, hit network and use returnCachedAsset if it fails
      return fetch(e.request).catch(returnCachedAsset);
    })(),
  );
});
